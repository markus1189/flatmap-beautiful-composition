 \documentclass[aspectratio=169]{beamer}

% Must be loaded first
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}

\usepackage[utf8]{inputenc}
\usepackage{textpos}

% Font configuration
\usepackage{fontspec}

\input{font.tex}

% Tikz for beautiful drawings
\usetikzlibrary{mindmap,backgrounds}
\usetikzlibrary{arrows.meta,arrows}
\usetikzlibrary{shapes.geometric}

% Minted configuration for source code highlighting
\usepackage{minted}
\setminted{highlightcolor=black!5, linenos}
\setminted{style=lovelace}

\usepackage[listings, minted]{tcolorbox}
\tcbset{left=6mm}

% Use the include theme
\usetheme{codecentric}

% Metadata
\title{Beautiful Composition}
\author{Markus Hauck}

% The presentation content
\begin{document}

\begin{frame}[noframenumbering,plain]
  \titlepage{}
\end{frame}

\section{Introduction}\label{sec:introduction}

\begin{frame}
  \frametitle{Just Imagine}
  \begin{itemize}
  \item a world where your abstractions just fit together
  \item like lego blocks
  \item combinations everywhere
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Beautiful Composition}
  \begin{itemize}
  \item Themes in this presentation:
    \begin{itemize}
    \item open for extension, closed for modification
    \item composition, composition, composition
    \item the principle of least power
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Content}
  \begin{itemize}
  \item \hyperref[sec:introduction]{Introduction}
  \item \hyperref[sec:monoids]{Monoids}
  \item \hyperref[sec:applicatives]{Applicatives}
  \item \hyperref[sec:streaming]{Streaming}
  \item \hyperref[sec:conclusion]{Conclusion}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Open Closed Principle}
  \begin{itemize}
  \item remember the open closed principle?
  \item open for extension
  \item closed for modification
  \item if applied correctly, this means heaven
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Principle Of Least Power}
  \begin{itemize}
  \item https://www.w3.org/DesignIssues/Principles.html
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Composition}
  \begin{itemize}
  \item what is composition
  \item why it is important
  \item how to achieve it
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Ways To Compose}
  \begin{itemize}
  \item nesting (composition)
  \item tupling (multiple components in parallel)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Case Study}
  \begin{itemize}
  \item we want to analyze text
  \item collect metrics
  \item single traversal
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A First Solution}
  \inputminted[fontsize=\small]{scala}{snippets/imperative-wc.scala}
\end{frame}

\begin{frame}
  \frametitle{Metrics}
  \begin{itemize}
  \item number of chars (count each char)
  \item number of lines (count newline characters)
  \item number of words (harder, because it is context sensitive)
  \item open for extension (closed for modification)
  \end{itemize}
\end{frame}

\section{Monoids}\label{sec:monoids}

\begin{frame}
  \frametitle{Let's Get Our FP Tools!}
  % image of toolset?
\end{frame}

\begin{frame}[fragile]
  \frametitle{Monoids}
  \begin{itemize}
  \item Quick Recap: Monoids
  \item binary method \texttt{combine} and nullary method \texttt{combine}
    \begin{minted}{scala}
      trait Monoid[A] {
        def combine(x: A, y: A): A
        def empty: A
      }
    \end{minted}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Monoids: Basic Idea}
  \begin{itemize}
  \item basic approach: iterate over all \texttt{Char} and accumulate using a monoid
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Monoids}
  \begin{tikzpicture}[node distance = 2cm, auto]
    \tikzstyle{decision} = [diamond, draw, fill=blue!20,
    text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\tikzstyle{block} = [rectangle, draw, fill=blue!20,
    text width=5em, text centered, rounded corners, minimum height=4em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{cloud} = [draw, ellipse,fill=red!20, node distance=3cm,
minimum height=2em]

    % Place nodes
    \node [block] (init) {initialize model};
    \node [cloud, left of=init] (expert) {expert};
    \node [cloud, right of=init] (system) {system};
    \node [block, below of=init] (identify) {identify candidate models};
    \node [block, below of=identify] (evaluate) {evaluate candidate models};
    \node [block, left of=evaluate, node distance=3cm] (update) {update model};
    \node [decision, below of=evaluate] (decide) {is best candidate better?};
    \node [block, below of=decide, node distance=3cm] (stop) {stop};
    % Draw edges
    \path [line] (init) -- (identify);
    \path [line] (identify) -- (evaluate);
    \path [line] (evaluate) -- (decide);
    \path [line] (decide) -| node [near start] {yes} (update);
    \path [line] (update) |- (identify);
    \path [line] (decide) -- node {no}(stop);
    \path [line,dashed] (expert) -- (init);
    \path [line,dashed] (system) -- (init);
    \path [line,dashed] (system) |- (evaluate);
\end{tikzpicture}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Monoids: Counting Chars}
  \begin{itemize}
  \item counting chars is easy, use \texttt{(Int, +)} as a Monoid
  \item count 1 (\texttt{mappend} 1) for every character
  \end{itemize}
  \begin{tikzpicture}[node distance = 8mm, auto]
    \tikzstyle{box} = [rectangle, draw, text centered, rounded corners, minimum width=6mm, minimum height=6mm]
    \tikzstyle{line} = [draw, -latex']

    \node [box, draw=none] (a0) {};

    \foreach \char [count=\pos, evaluate=\pos as \i using int(\pos-1)] in {h,e,l,l,o,\textbackslash{n},w,o,r,l,d,!,\textbackslash{n}} {
      \ifthenelse{\isodd{\pos}}{
        \node [box, fill=beamer@codeblue!70, right of=a\i] (a\pos) {\char};
      }{
        \node [box, fill=beamer@centricgreen!70, right of=a\i] (a\pos) {\char};
      }
      \only<\pos>{
        \node [box, below of=a\pos, yshift=-5mm] (b\pos) {\i\ + 1 = \pos};
        \path [line] (b\pos) -- (a\pos);
      }
    }
  \end{tikzpicture}

  \vfill
  \only<13>{
    \begin{itemize}
    \item so the result is 13 chars in total
    \end{itemize}
  }
\end{frame}

\begin{frame}[fragile]
  \frametitle{Monoids: Counting Chars}
  \begin{itemize}
  \item to count lines, use again \texttt{(Int, +)} as a Monoid
  \item but \textbf{only} count 1 if the character is a \textbackslash{n}
  \end{itemize}
  \begin{tikzpicture}[node distance = 8mm, auto]
    \tikzstyle{box} = [rectangle, draw, text centered, rounded corners, minimum width=6mm, minimum height=6mm]
    \tikzstyle{line} = [draw, -latex']

    \node [box, draw=none] (a0) {};

    \foreach \char [count=\pos, evaluate=\pos as \i using int(\pos-1)] in {h,e,l,l,o,\textbackslash{n},w,o,r,l,d,!,\textbackslash{n}} {
      \ifthenelse{\isodd{\pos}}{
        \node [box, fill=beamer@codeblue!70, right of=a\i] (a\pos) {\char};
      }{
        \node [box, fill=beamer@centricgreen!70, right of=a\i] (a\pos) {\char};
      }
      \only<\pos>{
        \ifthenelse{\pos > 5}{
          \ifthenelse{\pos > 12}{
            \node [box, below of=a\pos, yshift=-5mm] (b\pos) {1\ + 1 = 2};
          }{
            \ifthenelse{\pos = 6}{
              \node [box, below of=a\pos, yshift=-5mm] (b\pos) {0\ + 1 = 1};
            }
            {
              \node [box, below of=a\pos, yshift=-5mm] (b\pos) {1\ + 0 = 1};
            }
          }
        }{
          \node [box, below of=a\pos, yshift=-5mm] (b\pos) {0 + 0 = 0};
        }
        \path [line] (b\pos) -- (a\pos);
      }
    }
  \end{tikzpicture}

  \only<13>{
    \begin{itemize}
    \item we counted 2 lines in total
    \end{itemize}
  }
\end{frame}

\begin{frame}
  \frametitle{Calculating With Monoids}
  \begin{itemize}

  \item adding things (or multiplying)
  \item min and max
  \item map of key to value (for any monoid as value)
  \item ...
  \item we can calculate our metrics with monoids
  \item chars is the integer monoid with addition
  \item lines is also the integer monoid, but only count 1 if char is a newline
  \item for words, for now just split the input and count 1 on every ``group''
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Metrics With Monoids}
  \begin{itemize}
  \item calculate some metrics like: words, chars, lines
  \item some metrics cannot be expressed however
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{You can nest monoids}
  \begin{itemize}
  \item monoids compose naturally
  \item handy because future of monoid is still a monoid
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Products of Monoids}
  \begin{itemize}
  \item a tuple of monoids is still a monoid, that works component wise
  \item handy for our case study!
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Wordcount (Monoids, Chars)}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/wc-monoid-char.scala}
\end{frame}

\begin{frame}
  \frametitle{Wordcount (Monoids, Strings)}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/wc-monoid-string.scala}
\end{frame}

\section{Applicatives}\label{sec:applicatives}

\begin{frame}
  \frametitle{From Monoids To Applicatives}
  \begin{itemize}
  \item also called \textbf{Monoidal} Functors
  \item ``monoidal'' in the effects (pure = ``empty'' effect, \texttt{<*>} = ``combine effects'')
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{No Monoids?}
  \begin{itemize}
  \item but wait a moment, was all we learned about Monoids for nothing?!
  \item rejoice, we can reuse \textbf{everything} we have until now
  \item as we will see later
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Metrics via Applicatives}
  \begin{itemize}
  \item using applicatives we have all the power we need
  \item use State, IO, Task, \ldots
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Const Functor}
  \begin{itemize}
  \item the functor instance is a little strange
  \item but the applicative instance is super awesome
  \item allows you to lift any monoid into an applicative
  \item that means we can still use everything we already have
  \item (nb: Const is a monoid isomorphism)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Traversing With Applicatives}
  \begin{itemize}
  \item instead of folding with monoids
  \item \texttt{traverse} with applicatives
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Composing Applicatives}
  \begin{itemize}
  \item so why not monads
  \item applicatives compose (Nested)
  \item and also work as a product (Tuple2K)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Counting Words \textemdash{} With State}
  \begin{itemize}
  \item we can re-use the counting of chars and lines (and any monoidal metric)
  \item as seen, have to be more clever for words
  \item idea: keep track of state: \textbf{inside} vs \textbf{outside} a word
  \item how to do this with applicatives?
  \item \textbf{State}, IO, ST, \ldots{}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{State makes everything more complicated}
  \begin{itemize}
  \item but \textbf{State} has severe drawbacks\dots
  \item TODO: semantics of traversing with state
  \item get rid of the leak using IO + Ref (cats-effect)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Using Foldable and Traverse}
  \begin{itemize}
  \item we can use Foldable and Traverse to abstract over the data structure
  \item both can also be composed in turn!
  \end{itemize}
\end{frame}

\section{Streaming}\label{sec:streaming}

\begin{frame}
  \frametitle{Okay but traversing Lists/Iterators/etc is suboptimal!}
  \begin{itemize}
  \item but there is no \texttt{traverse} for real streams?!
  \item because there can't be one\ldots
  \item but: do we need the actual \texttt{traverse}?
  \item realization: \texttt{traverse\_} is enough!
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Traverse and Foldable}
  \begin{itemize}
  \item so what's the difference between \texttt{traverse} and \texttt{traverse\_}
  \item the regular \texttt{traverse} keeps the whole structure!
  \item the \texttt{traverse\_} variant only secquences effects!
  \item and again: Applicative effect sequencing is associative (parallel!)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Traversing with State}
  \begin{itemize}
  \item using State, we can still iterate imperatively
  \item but we can keep keep the parts separate and \textbf{compose} them!
  \item all the power from the normal imperative approach with all the benefits
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Traversing Streams}
  \begin{itemize}
  \item calculate length as well as do something
  \item log element and also write to db
  \item keep concerns separate and isolated
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Composition}
  \begin{itemize}
  \item use \texttt{Nested} to nest applicatives for ultimate power
  \item separate state update and retrieval + counting
  \item important gotcha: no real streaming depending on the applicative! (state...)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Tradeoffs}
  \begin{itemize}
  \item streaming is not possible with this approach, but only an example
  \item abstractions like Monoid and Applicative compose nicely
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Monadic composition?}
  \begin{itemize}
  \item monadic composition is not nearly as nice
  \item needs commutative monads
  \item see essence iterator 5.4
  \end{itemize}
\end{frame}

\section{Conclusion}\label{sec:conclusion}

\begin{frame}
  \frametitle{Conclusion}
  \begin{itemize}
  \item we can add metrics easily
  \item control flow can be easily customized
  \item (Sometimes) Monads are overrated
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The End}
  \begin{itemize}
  \item \hyperref[sec:introduction]{Introduction}
  \item \hyperref[sec:monoids]{Monoids}
  \item \hyperref[sec:applicatives]{Applicatives}
  \item \hyperref[sec:streaming]{Streaming}
  \item \hyperref[sec:conclusion]{Conclusion}
  \end{itemize}
\end{frame}

\appendix{}

\begin{frame}
  \frametitle{Brand New: Selective Functors}
  \begin{itemize}
  \item like applicatives, we can use a product of selective functors
  \item example: find the index of a word
  \end{itemize}
\end{frame}

\end{document}
