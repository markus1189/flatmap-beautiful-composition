\documentclass{beamer}

% Must be loaded first
\usepackage{tikz}

\usepackage[utf8]{inputenc}
\usepackage{textpos}

% Font configuration
\usepackage{fontspec}

\input{font.tex}

% Tikz for beautiful drawings
\usetikzlibrary{mindmap,backgrounds}
\usetikzlibrary{arrows.meta,arrows}
\usetikzlibrary{shapes.geometric}

% Minted configuration for source code highlighting
\usepackage{minted}
\setminted{highlightcolor=black!5, linenos}
\setminted{style=lovelace}

\usepackage[listings, minted]{tcolorbox}
\tcbset{left=6mm}

% Use the include theme
\usetheme{codecentric}

% Metadata
\title{Free All The Things}
\author{Markus Hauck}

\newcommand{\recipe}{%
  \begin{itemize}
  \item AST
  \item \texttt{inject}
  \item interpreter
  \item check laws
  \end{itemize}
}

% The presentation content
\begin{document}

\begin{frame}[noframenumbering,plain]
  \titlepage{}
\end{frame}

\section{Introduction}\label{sec:introduction}

\begin{frame}
\frametitle{Beautiful Composition}
\begin{itemize}
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Composition}
  \begin{itemize}
  \item what is composition
  \item why it is important
  \item how to achieve it
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Problem with Patterns}
  \begin{itemize}
  \item there a lot of standard patterns
  \item but they do not easily compose
  \item need to combine them in some ad-hoc way
  \item quickly becomes very messy
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Ways To Compose}
  \begin{itemize}
  \item nesting (composition)
  \item tupling (multiple components in parallel)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Case Study}
  \begin{itemize}
  \item we want to analyze text
  \item collect metrics
  \item single traversal
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Metrics}
  \begin{itemize}
  \item number of chars (count each char)
  \item number of lines (count newline characters)
  \item number of words (harder, because it is context sensitive)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Monoids}
  \begin{itemize}
  \item we can calculate our metrics with monoids
  \item chars is the integer monoid with addition
  \item lines is also the integer monoid, but only count 1 if char is a newline
  \item for words, for now just split the input and count 1 on every ``group''
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Metrics With Monoids}
  \begin{itemize}
  \item calculate some metrics like: words, chars, lines
  \item some metrics cannot be expressed however
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{You can nest monoids}
  \begin{itemize}
  \item monoids compose naturally
  \item handy because future of monoid is still a monoid
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Products of Monoids}
  \begin{itemize}
  \item a tuple of monoids is still a monoid, that works component wise
  \item handy for our case study!
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{From Monoids To Applicatives}
  \begin{itemize}
  \item applicative functors are very similar to monoids
  \item monoidal in the effects (pure = ``empty'' effect, ap = ``effect chaining'')
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Const Functor}
  \begin{itemize}
  \item the functor instance is a little strange
  \item but the applicative instance is super awesome
  \item allows you to lift any monoid into an applicative
  \item that means we can still use everything we already have
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Metrics via Applicatives}
  \begin{itemize}
  \item using applicatives we have all the power we need
  \item use State, IO, Task, \dots
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Tradeoffs}
  \begin{itemize}
  \item streaming is not possible with this approach, but only an example
  \item abstractions like Monoid and Applicative compose nicely
  \end{itemize}
\end{frame}

\section{Conclusion}\label{sec:conclusion}

\begin{frame}
\end{frame}

\appendix{}

\end{document}
